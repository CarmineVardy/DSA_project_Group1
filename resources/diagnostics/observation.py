from fhir.resources.observation import Observation as FhirObservation

from enum import Enum
from typing import Optional, List, Dict
from datetime import datetime

from resources.core.types import AppCodeableConcept

class ObservationStatus(str, Enum):
    REGISTERED = "registered"
    PRELIMINARY = "preliminary"
    FINAL = "final"
    AMENDED = "amended"
    CORRECTED = "corrected"
    CANCELLED = "cancelled"
    ENTERED_IN_ERROR = "entered-in-error"
    UNKNOWN = "unknown"

    @property
    def definition(self) -> str:
        #https://hl7.org/fhir/R4/valueset-observation-status.html
        definitions = {
            "registered": "The existence of the observation is registered, but there is no result yet available.",
            "preliminary": "This is an initial or interim observation: data may be incomplete or unverified.",
            "final": 'The observation is complete and there are no further actions needed. Additional information such "released", "signed", etc would be represented using [Provenance](provenance.html) which provides not only the act but also the actors and dates and other related data. These act states would be associated with an observation status of `preliminary` until they are all completed and then a status of `final` would be applied.',
            "amended": "Subsequent to being Final, the observation has been modified subsequent. This includes updates/new information and corrections.",
            "corrected": "Subsequent to being Final, the observation has been modified to correct an error in the test result.",
            "cancelled": 'The observation is unavailable because the measurement was not started or not completed (also sometimes called "aborted").',
            "entered-in-error": 'The observation has been withdrawn following previous final release. This electronic record should never have existed, though it is possible that real-world decisions were based on it. (If real-world activity has occurred, the status should be "cancelled" rather than "entered-in-error".).',
            "unknown": 'The authoring/source system does not know which of the status values currently applies for this observation. Note: This concept is not to be used for "other" - one of the listed statuses is presumed to apply, but the authoring/source system does not know which.'
        }
        return definitions.get(self.value, "Definition not available.")

class ObservationCategory(str, Enum):
    SOCIAL_HISTORY = "social-history"
    VITAL_SIGNS = "vital-signs"
    IMAGING = "imaging"
    LABORATORY = "laboratory"
    PROCEDURE = "procedure"
    SURVEY = "survey"
    EXAM = "exam"
    THERAPY = "therapy"
    ACTIVITY = "activity"

    @property
    def definition(self) -> str:
        #https://hl7.org/fhir/R4/valueset-observation-category.html
        definitions = {
            "social-history": "Social History Observations define the patient's occupational, personal (e.g., lifestyle), social, familial, and environmental history and health risk factors that may impact the patient's health.",
            "vital-signs": "Clinical observations measure the body's basic functions such as blood pressure, heart rate, respiratory rate, height, weight, body mass index, head circumference, pulse oximetry, temperature, and body surface area.",
            "imaging": "Observations generated by imaging. The scope includes observations regarding plain x-ray, ultrasound, CT, MRI, angiography, echocardiography, and nuclear medicine.",
            "laboratory": "	The results of observations generated by laboratories. Laboratory results are typically generated by laboratories providing analytic services in areas such as chemistry, hematology, serology, histology, cytology, anatomic pathology (including digital pathology), microbiology, and/or virology. These observations are based on analysis of specimens obtained from the patient and submitted to the laboratory.",
            "procedure": "Observations generated by other procedures. This category includes observations resulting from interventional and non-interventional procedures excluding laboratory and imaging (e.g., cardiology catheterization, endoscopy, electrodiagnostics, etc.). Procedure results are typically generated by a clinician to provide more granular information about component observations made during a procedure. An example would be when a gastroenterologist reports the size of a polyp observed during a colonoscopy.",
            "survey": "Assessment tool/survey instrument observations (e.g., Apgar Scores, Montreal Cognitive Assessment (MoCA)).",
            "exam": "	Observations generated by physical exam findings including direct observations made by a clinician and use of simple instruments and the result of simple maneuvers performed directly on the patient's body.",
            "therapy": "Observations generated by non-interventional treatment protocols (e.g. occupational, physical, radiation, nutritional and medication therapy).",
            "activity": "Observations that measure or record any bodily activity that enhances or maintains physical fitness and overall health and wellness. Not under direct supervision of practitioner such as a physical therapist. (e.g., laps swum, steps, sleep data)."
        }
        return definitions.get(self.value, "Definition not available.")

class AppObservation:
    def __init__(self, raw_json_data: dict):
        self.resource = FhirObservation(**raw_json_data)

    @property
    def id(self):
        return self.resource.id

    @property
    def status(self) -> Optional[ObservationStatus]:
        if not self.resource.status:
            return None
        try:
            return ObservationStatus(self.resource.status)
        except ValueError:
            return None

    @property
    def category(self) -> Optional[ObservationCategory]:
        if not self.resource.category:
            return None
        for cat in self.resource.category:
            found_enum = AppCodeableConcept(cat).bind_to(ObservationCategory)
            if found_enum:
                return found_enum
        return None

    @property
    def code_text(self) -> Optional[str]:
        if not self.resource.code:
            return None
        return AppCodeableConcept(self.resource.code).readable_value

    @property
    def code_details(self) -> List[Dict[str, Optional[str]]]:
        if not self.resource.code:
            return []    
        return AppCodeableConcept(self.resource.code).coding_details

    @property
    def effective_date(self) -> Optional[datetime]:
        return self.resource.effectiveDateTime

    def _get_value_from_source(self, source) -> Optional[str]:
        if source.valueQuantity:
            q = source.valueQuantity
            if q.value is None:
                return None
            parts = []
            if q.comparator: parts.append(q.comparator)
            parts.append(str(q.value))
            if q.unit: parts.append(q.unit)
            return " ".join(parts)

        if source.valueCodeableConcept:
            return AppCodeableConcept(source.valueCodeableConcept).readable_value

        if source.valueString:
            return source.valueString
            
        return None

    @property
    def value_text(self) -> Optional[str]:
        return self._get_value_from_source(self.resource)

    @property
    def component_text(self) -> Optional[str]:
        if not self.resource.component:
            return None
        items = []
        for comp in self.resource.component:
            name = AppCodeableConcept(comp.code).readable_value or ""
            val = self._get_value_from_source(comp)
            if val:
                items.append(f"{name}: {val}")
        return ", ".join(items) if items else None

    def to_prompt_string(self) -> str:
        header_name = self.code_text
        value = self.value_text
        components = self.component_text
        
        if not value and not components:
            return ""

        meta_parts = []
        if self.status:
            meta_parts.append(f"({self.status.value.capitalize()})")
        
        if self.effective_date:
            meta_parts.append(f"[{self.effective_date.strftime('%Y-%m-%d')}]")
        
        header_line = f"- {header_name} {' '.join(meta_parts)}"

        result_parts = []
        if value:
            result_parts.append(value)
        if components:
            result_parts.append(components)
        
        result_line = f"  Result: {', '.join(result_parts)}"

        ref_line = ""
        codes = self.code_details
        if codes:
            code_strs = [f"{c['system']}: {c['code']}" for c in codes]
            ref_line = f"\n  Ref: {', '.join(code_strs)}"

        return f"{header_line}\n{result_line}{ref_line}"